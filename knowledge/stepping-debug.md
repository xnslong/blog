# 单步调试

单步调试是一个发现代码问题的重要手段, 它能让我们清楚看到程序运行时的内存状态, 线程栈等信息, 于是我们就能看着程序一步一步是如何运行的, 能迅速定位问题. 除了定位问题外, 单步调度也是跟踪代码逻辑的一个很好的手段, 对于一个复杂的系统, 它能带着我们轻松梳理出其中的调用链来. 不同语言都有各自的调度手段, 比如对于C语言, 我们可以用cdb调试; java可以用jdb调试. 这里是使用java单步调试来说明的, 但是所说的东西对于他们大多是相通的.

不过就是这样一个简单的功能, 使用并不是总如想像的那么容易. 比如对于一个复杂的系统, 我们要单步运行的话, 

1. 我们一般都需要在合适的地方打断点, 那么应该怎么确定要在什么地方打断点?
2. 我们单步执行的每一步里面可能都是一个很大的调用树, 那么单步的时候应该跟进子树里面去, 还是直接跟下一步方法调用? 怎么选择?

这些问题在特定的场合下都有一些特定的处理方式, 使达到快速定位问题点的目的. 这大概就是为什么很多老司机查问题很快的一个原因. 不过在介绍这些处理方式之前, 先需要说一个单步调试容易出现的坑——代码不一致.

## 保证代码一致

> 曾经有一位同学为了查一个问题, 也用了单步调度, 但是他调试过程中发现了一个无法解释的现象: 除以0没有报错! 他看到的代码大概是这样的
>
> ```java
> int z = x / y;
> ```
>
> 然后单步调试的时候能看到`x = 7`, `y = 0`, 结果这一步计算成功了, 而且`z`也得到了一个值`7`. 当时的现象有点让他不能理解, 他甚至都开始怀疑JVM是不是有BUG, 是不是整数除以0有什么特殊的情况不报错...这样做了一堆想象, 都快怀疑人生了. 最后我帮忙一块看的时候, 觉得很有可能代码不是按照这个逻辑跑的, 于是check了一下对应的代码版本, 发现果然版本不一样, 找到对应版本的代码发现运行的逻辑是
>
> ```java
> int z = x - y;
> ```
>
> 只不过他的IDE中开的版本并非运行时真正的版本. 

这种参考的代码与运行时代码不一致, 在日常开发工作中是常见的. 比如我们IDE中的代码会停留在某个开发分支上, 而运行中的代码是另一个分支的; 或者我们的各种版本号都对, 但是依赖的SNAPSHOT在部署运行之后, 又有了更新, 导致IDE中的版本与实际运行的版本不一致. 这些不一致会给我们的调试工作带来很多干扰, 甚至会影响我们判断的正确性. 

版本不一致, 在调试的时候我们可能就会发现一些莫名其妙的问题. 比如前面的说`"除0"不报错`, 空指针不报错, 没有空指针的时候报错了...等等. 再有代码行号对不上, 对应行上没有代码这些情况, 一般也都是代码版本不一致的结果. 所以如果单步调试的时候发现了如上的情况, 可以首先怀疑版本是否一致. 

确定版本是否一致的方法一般有几类: 

1. 看运行中的jar包的版本号与IDE中所看的版本号是否一致, 比如运行中的版本号是`1.0.1`, 而IDE中的源码版本号是`1.0.2`, 那很可能就是不一致的. 这对于所有`RELEASE`的版本应该都适用, 比如从中央仓库引入的依赖.
2. 我们也可以将git版本号打到代码包中([maven plugin](https://github.com/git-commit-id/maven-git-commit-id-plugin)), 检查运行时jar中的版本号与IDE中的源码包版本号是否一致. 这种情况在同一个`SNAPSHOT`版本被反复更新的时候会很有帮助, 它能准确地告诉我们当前所看的版本号与运行中的代码是否一致. 
3. 使用反编译工具(比如[JD](http://java-decompiler.github.io))直接反编译运行时的jar包, 对比反编译的代码与IDE中的代码是否一致. 

确定了版本一致, 然后再进行单步调试, 这才是有意义的, 不然可能大量的时间会浪费在一些不存在的问题上.

## 确定断点

回到正题上来, 我们一般一个复杂系统, 调用关系都是很复杂的: 每一个方法都是从上一级的某个方法调用而来, 而方法处理过程中又会发起更多的调用 (如下图所示), 于是这样的一个方法结点就而了一个多叉树中的一个分支结点, 所有前后级的调用就组成了一棵调用树, 系统执行过程就是在遍历这一棵树, 而任何一个时候的方法调用栈就是遍历到当前结点时的一个路径. 这个调用树一般会非常庞大, 那么要怎么从这个庞大的调用树中找到问题点呢?  

> 一般来说, 复杂系统中一个方法调用的调用栈深度达到几十层上百层是很正常的, 我们就假设是平均20层; 而一个方法里面对外调用的个数达到10个也比较常见, 我们保守假设只有2个对外调用, 所以整个调用过程的调用树就可以理解为是一棵深度为20的二叉树. 这样一个二叉树里面的结点总个数可以达到`2^0 + 2^1 + ... + 2^20 = 2097151`, 每一个结点都是我们调用过程中的调用栈里面的一个栈帧. 当我们需要用单步调试来排查问题的时候, 需要排查的问题就是这200万个结点中的某一个或多个结点处理得不对造成的. 
> 显然直接从最开始一直单步遍历完整棵调用树是不合适的, 那样查一个问题需要非常久的时间. 我们单步调试是需要看当时的各种系统状态的, 并用这些状态判断它是否有问题. 就算判断能很快完成, 每一步只需要5秒钟就可以判断完是否有问题, 那么遍历完整棵树大概需要`5 * 2097151 / 86400 = 121天`. 想想用100多天才查出一个方法中的问题, 这应该是谁也无法接受的. 

```plantuml
participant A
box children
participant B

participant C

participant G
end box

[-> A: handle A method
activate A

A -> B: call child method
activate B
A <-- B
deactivate B

A -> C: call child method
activate C
A <-- C
deactivate C

...10 more child calls...
A -> G: call child method
activate G
A <-- G
deactivate G

[<--A
deactivate A
```

我们发现系统有问题, 往往是某些现象出现了. 比如发现了报空指针异常, 发现数据跟想象中的不一样, 发现意外的日志... 这些地方就是很好的初始断点. 

> **从问题发生的位置开始断点**

从这些点开始断, 我们可以快速找到问题已经发生的现场, 从现场开始分析能很容易找到问题的根源. 就像发生了凶案一样, 警察做的第一件事不是查所有人, 而是先勘查现场, 这是同一个道理的. 

## 现场分析

单步调试最大的一个优点就是我们可以清楚地看到内存中的各种状态. 能看到的状态包括:

1. 能看到当前调用栈, 能明确调用路径是什么样的, 可以用于确认调用路径上有没有经过某个期望的或者不期望的结点.
2. 能看到各层栈结点的现场, 包括参数是什么样的, 各局部变量是什么样的, this是什么, 各个字段是什么样的.
3. 能用evaluate进行现场的各种计算.

系统问题发生需要单步调试, 一定能在这样的一些现场中找到意料之外的值. 单步调试需要明确是哪些值的异常导致了问题的发生. 这可以根据源码的逻辑来进行判断, 比如下面的这样一行代码抛了空指针异常(`NullPointerException`), 那么有可能`user`是`null`, 也有可能`user.getAge()`返回的是`null`(假设这个方法能返回`null`, 表示它不愿意透露年纪). 这个时候我们需要关注的现场就是`user`的值(是否为`null`), 以及它的`getAge()`方法返回了什么. 

```java
int age = user.getAge();
```

